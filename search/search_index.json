{"config":{"lang":["nl"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Webtechnologie 2","text":"<p>Dit vak gaat verder op de basis die in het vak Webtechnologie in de propedeuse is gelegd. In dit thema richten we ons op de backend van webapplicaties, waarbij de we server gebruiken om web-inhoud te genereren. Vanuit een korte historische inleiding lichten we toe waarom het web werkt zoals het werkt, gaan we in op de verschillende protocollen die hieraan ten grondslag liggen, en bespreken we ontwerpbeslissingen die het web maken wat het is. We gaan uitgebreid in op methoden en technieken die in hedendaagse webapplicaties gebruikt worden, waarbij we met name letten op de testbaarheid, onderhoudbaarheid en overdraagbaarheid van de applicatie.</p> <p>Het vak wordt afgesloten met een eindopdracht, waar studenten gedurende de periode aan werken. De eindopdracht wordt aan de hand van een beoordelingsformulier met een cijfer beoordeeld. Studenten mogen de opdracht in duo's doen, mits hierbij gebruik gemaakt wordt van pair programming. </p> <p>Deze pagina's zijn bedoeld om studenten op weg te helpen met de eindopdracht.</p>"},{"location":"week3%20-%20http/iteratie1.html","title":"iteratie 1: een volledige round-trip","text":""},{"location":"week3%20-%20http/iteratie1.html#beschrijving-van-de-inhoud","title":"Beschrijving van de inhoud","text":"<p>Tijdens het werkcollege pas je de ingebouwde functionaliteiten die PHP heeft om web requests te verwerken toe, met name de zogeheten superglobals. Daarnaast ga je aan de slag met het framework Symfony; dit framework zal gedurende het vak gebruikt worden als concreet voorbeeld van de behandelde patterns. In dit werkcollege pas je de component HttpFoundation toe, die de request- en responsestructuur van Symfony omvat.</p> <p>Je begint met de ontwikkeling van de eigen webapplicatie voor de eindopdracht door een eigen request handling component te ontwikkelen aan de hand van de patterns die in de colleges aan bod gekomen zijn. </p>"},{"location":"week3%20-%20http/iteratie1.html#stap-1-installeer-de-afhankelijkheden","title":"stap 1: installeer de afhankelijkheden","text":"<p>Nadat je de repository hebt gecloned, moet je de afhankelijkheden (dependencies) nog downloaden. De dependency-manager van php is composer. Zie ook de betreffende kennisclip hierover.  Composer maakt gebruik van het bestand <code>package.json</code> om te checken welke afhankelijkheden er allemaal in het project zitten. Als je op dit bestand klikt, verschijnt er een dialoogvenster waarmee je direct composer kunt downloaden. Als dit gedaan is, kun je vervolgens de dependencies installeren: die komen in de directory <code>vendor</code> terecht.</p> <p> </p>"},{"location":"week3%20-%20http/iteratie1.html#stap-2-bestudeer-en-implementeer-de-message-gerelateerde-interfaces","title":"stap 2: bestudeer en implementeer de <code>Message</code>-gerelateerde interfaces.","text":"<p>Bestudeer de interfaces die gedefinieerd zijn in <code>vendor/Psr/http-message/src</code>. Deze week gaat het met name om de interfaces waarvan hieronder het diagram is weergegeven. </p> <p></p> <p>Wat is het fundamentele werk dat een web-framework moet doen? Het omzetten van een <code>ServerRequest</code> in een <code>Response</code>. Niet toevalligerwijs zie je deze twee klassen in het schema onderaan weergegeven. De klasse <code>ServerRequest</code> implementeert de interface <code>ServerRequestInterface</code> en de klasse <code>Response</code> implementeert de interface <code>ResponseInterface</code>. </p> <p>Zoals je ziet overeft <code>ServerRequest</code> van <code>Request</code> en overerft zowel <code>Request</code> als <code>Response</code> van <code>Message</code>. Allereerst zul je dus deze hele hi\u00ebrarchie van interfaces in implementerende klassen moeten weerspiegelen: doe dit in de directory <code>Http</code>. Als je in een klasse de betreffende interface implementeert, kun je met phpstorm automatisch stubs voor de betreffende methoden genereren.</p> <p>Tip</p> <p>Het is handigste wanneer je met het implementeren van de interfaces begint met de bovenste klassen, <code>Message</code> dus in dit geval. Op die manier voorkom je dat phpstorm stubs genereert van de hele hi\u00ebrarchie van interfaces.</p> <p></p> <p><code>ServerRequest</code> en <code>Request</code></p> <p>Meestal spreken we over het omzetten van een <code>Request</code> in een <code>Response</code>; waar komt dan ineens die <code>ServerRequest</code> vandaan?</p> <p>Als je de docs leest, staat er bij <code>Request</code> dat dit een representatie is van een outgoing, client side request, terwijl er bij <code>ServerRequest</code> staat dat dit een representatie is van een incoming, server side HTTP request. Het punt is dat webframeworks dikwijls zelf ook een request moeten maken, bijvoorbeeld naar een andere service of API. Hier is de <code>Request</code> voor nodig. Het <code>ServerRequest</code> is datgene dat het framework ontvangt, terwijl het <code>Request</code> datgene is dat de server (intern) verstuurt.</p>"},{"location":"week3%20-%20http/iteratie1.html#stap-3-de-kernel","title":"Stap 3: De Kernel","text":"<p>Nu hebben we al bijna de hele infrastructuur die nodig is om een eerste round trip te kunnen uitvoeren. Het enige dat we nog nodig hebben is de Kernel.</p> <p>In een web-framework is de Kernel de kern van de applicatie \ud83d\ude0e. Het is de centrale klasse die verantwoordelijk is voor het opstarten, configureren, en afhandelen van verzoeken. We gaan dit ding in de komende weken nog uitgebreid tegenkomen, maar voor nu hoeft -ie niet zo gek veel te doen.</p> <p>Maak een klasse <code>Kernel</code> die de <code>KernelInterface</code> implementeert (die staat in <code>vendor/hanze/itvb21web2-interfaces/src/Kernel</code>). Zoals je ziet overerft dit ding van <code>RequestHandlerInterface</code> die maar \u00e9\u00e9n methode heeft: <code>handle(ServerRequest):Response</code>. D\u00edt is dus de methode die uiteindelijk een request omzet in een response.</p> <p>Maak in de <code>handle</code>-methode van <code>Kernel</code> een nieuwe <code>Response</code> aan met gewoon een hard gecodeerde tekst als inhoud. Retourneer dit nieuwe object.</p>"},{"location":"week3%20-%20http/iteratie1.html#stap-4-de-klasse-request-en-response","title":"Stap 4: de klasse <code>Request</code> en <code>Response</code>","text":"<p>De methode <code>handle</code> moet een <code>ResponseInterface</code> teruggeven. Gelukkig hebben we hierboven een klasse <code>Response</code> gemaakt dit deze interface implementeert. Dit ding is een subklasse van <code>Message</code>, die in de constructor onder andere een string mee kan krijgen. Maak in <code>Response</code> een constructor die een string ontvangt en geef deze string door aan de superklasse. </p> <p>De constructor van <code>Message</code> vereist nog twee andere parameters: <code>protocol_version</code> en <code>headers</code>. Voor nu is het prima als je gewoon <code>\"1.1\"</code> en een lege array in stopt.</p> <p>Tip</p> <p>Een constructor in een php-klasse heeft de signature <code>public function __construct(...)</code>. Om de constructor van de superklasse aan te roepen, gebruik je <code>parent::__construct(...)</code>.</p> <p>De klasse <code>Request</code> is ook een subklasse van <code>Message</code>. Voorzie <code>Request</code> van een constructor waarmee je standaardwaarden voor de vereiste parameters aan de superklasse meegeeft (<code>parent::construct(\"1/1\", []., \"\")</code>). In de volgende iteratie zullen we dit verbeteren.</p> <p>Implementeer tenslotte de methode <code>getBody()</code> in de klasse <code>Message</code>. Deze methode moet eenvoudig de <code>body</code> teruggeven die bij het aanmaken van een <code>Message</code> wordt meegegeven. Bestudeer de constructor van deze klasse om te zien hoe dit werkt.</p>"},{"location":"week3%20-%20http/iteratie1.html#de-frontcontroller","title":"De frontcontroller","text":"<p>In web-frameworks zoals deze is de frontcontroller het script dat het request in eerste instantie opvangt. In ons geval is dat het script <code>public/index.php</code>. Dit bestand bestaat nu nog uit maar \u00e9\u00e9n regel: <code>echo 'Hello world!;</code>. Het is de bedoeling dat we deze regel vervangen door het opzetten van de objecten-graaf op basis van de infrastructuur die we hierboven hebben gemaakt.</p> <pre><code>$app = new Kernel();\n$request = new ServerRequest();\n$response = $app-&gt;handle($request);\necho $response-&gt;getBody();\n</code></pre> <p>Nu kun je een server opstarten om de boel te testen. Ga naar de root van je project en start een php-ontwikkelserver op:</p> <pre><code>php -S localhost:8000 -t public\n</code></pre> <p>Als je nu met een browser naar <code>localhost:8000</code> gaat, zul je (als het goed is) de tekst te zien krijgen die je in de <code>handle</code>-methode van de Kernel hebt gebruikt om een <code>Response</code>-object aan te maken.</p> <p></p>"},{"location":"week3%20-%20http/iteratie2.html","title":"Iteratie 2: Uitbreiden van <code>ServerRequest</code> en <code>Response</code>","text":"<p>In de eerste iteratie hebben we gewoon een hard-gecodeerde string teruggegeven en maakten we helemaal geen gebruik van de mogelijkheden die het http ons biedt. In deze tweede iteratie gaan we dat aanpassen.</p>"},{"location":"week3%20-%20http/iteratie2.html#stap-1-superglobals-en-de-serverrequest-klasse","title":"Stap 1: superglobals en de <code>ServerRequest</code>-klasse","text":"<p>Bekijk de kennisclip over superglobals. Zoals hierin uitgelegd worden alle http-gerelateerde gegevens (en nog wel wat meer) opgeslagen in zogenaamde superglobals: globale variabelen die altijd overal beschikbaar zijn \u2013 zelfs zonder ze aan het begin van een methode te declareren.</p> <p>Op zich is dat heel fijn en makkelijk, maar het maakt onze code wel wat lastiger te testen en wat moeilijker te onderhouden. In principe willen we als software developers nooit gebruik maken van globals, laat staan superglobals. Verder willen we in onze php-applicatie eigenlijk alleen gebruik maken van php-variabelen, niet van relatief vreemde gegevens die schijnbaar zomaar uit de lucht komen vallen en eigenlijk meer in de http- dan bij de php-wereld thuishoren.</p> <p>Om dit te bewerkstelligen, moeten we ergens een vertaling maken van de http- naar de php-wereld. De meest aangewezen plek hiervoor is de klasse die verantwoordelijk is voor het opvangen van het inkomende request: de klasse <code>ServerRequest</code>.</p> <p>Deze klasse heeft op dit moment nog geen constructor, maar als je goed naar de methoden uit de interface kijkt, zie je dat dit ding de meeste http-gegevens encapsuleert. We moeten er dus voor zorgen dat instanties van <code>ServerRequest</code> beschikking krijgen over deze gegevens. Zoals je in de kennisclip hebt kunnen zien, zijn die min of meer functioneel onderverdeeld. Je hebt <code>$_GET</code>, <code>$_POST</code>, <code>$_SERVER</code> enzovoort. Klik hier voor het volledige overzicht.</p> <p>De algemene flow van onze frontcontroller wordt dan als volgt:</p> <p></p> <p>We moeten dus een instantie maken van de <code>ServerRequest</code>-klasse waardoor deze de superglobals kan encapsuleren. Maak in deze klasse een statische methode <code>fromGlobals()</code> die een <code>ServerRequest</code>-object teruggeeft. Zie het onderstaande code-fragment:</p> <pre><code>class ServerRequest {\n    public function __construct(private array $get) {}\n    public static function fromGlobals():ServerRequestInterface {\n        return new self($_GET);\n    }\n}\n</code></pre> <p>Warning</p> <p>Die methode <code>fromGlobals()</code> is de enige plek in ons framework waar we gebruik maken van die superglobals. Overal anders wordt vanaf nu gebruik gemaakt van deze instantie van die <code>ServerRequest</code>, die door deze methode teruggegeven wordt.</p> <p>Zoals aangegeven wordt in php de waarden na het vraagteken in de URL query parameters genoemd. Als we bijvoorbeeld een request doen naar <code>whatever.com/dingen?sleutel1=waarde1&amp;sleutel2=waarde2</code>, dan wordt de corresponderende <code>$_GET</code>:</p> <pre><code>Array\n(\n    [sleutel1] =&gt; waarde1\n    [sleutel2] =&gt; waarde2\n)\n</code></pre> <p>Maak van dit gegeven gebruik om de methode <code>getQueryParams</code> in <code>ServerRequest</code> te implementeren.</p>"},{"location":"week3%20-%20http/iteratie2.html#stap-2-de-handle-methode-in-de-kernel","title":"Stap 2: de <code>handle</code>-methode in de Kernel","text":"<p>Omdat de <code>handle</code>-methode in de Kernel die instantie van de <code>ServerRequest</code> mee krijgt, kunnen we hier gebruik maken van de methode <code>getQueryParams</code> die je hierboven hebt ge\u00efmplementeerd. Maak van deze mogelijkheid gebruik om de waarde van de sleutel <code>naam</code> op te halen, zodat iemand een request kan doen naar <code>localhost:8000:?naam=henk</code>.</p> <p>Gebruik de waarde die de bezoeker heeft ingetypt op je vriendelijke welkomstboodschap wat persoonlijker te maken. Hou er wel rekening mee dat de sleutel <code>naam</code> niet per se hoeft te bestaan: je moet dus een standaardwaarde hiervoor aangeven.</p> <p></p>"},{"location":"week4%20-%20mvc/iteratie3.html","title":"Iteratie 3: Model View Controller","text":""},{"location":"week4%20-%20mvc/iteratie3.html#beschrijving-van-de-inhoud","title":"Beschrijving van de inhoud","text":"<p>Je implementeert een model-view-controllerarchitectuur in de eigen webapplicatie voor de eindopdracht door eigen routing en templating componenten te ontwikkelen aan de hand van de patterns die in de colleges besproken zijn.</p> <p>Nu we in staat zijn om vanuit onze frontcontroller een stuk tekst in de browser te laten zien, is het zaak om deze tekst in een separaat bestand onder te brengen. Het zou immers niet handig zij om in onze Kernel alle mogelijke pagina's op te nemen die ons framework kan laten zien: dat zou de klasse erg vervuilen met html, wat de boel onoverzichtelijk en ononderhoudbaar zou maken. </p> <p>De html-bestanden die we gaan maken, vormen min of meer de View in het model-view-controller ontwerppatroon. Feitelijk zijn dit niet per se html-bestanden, maar meer staketsels van html, die we later via de controller gaan vullen met data uit het model. Hierom spreken we niet van html-bestanden, maar van html-templates, of kortweg templates.</p> <p></p> <p>Het is een beetje een discusie waar op je file system je deze templates neerzet, maar in deze uitwerking gaan we uit van een directory <code>tempates</code> die naast de directories <code>public</code> en <code>src</code> staat:</p> <pre><code>app/\n\u251c\u2500 composer.json\n\u251c\u2500 public/\n\u251c\u2500 src/\n\u251c\u2500 templates/\n\u251c\u2500 vendor/\n</code></pre>"},{"location":"week4%20-%20mvc/iteratie3.html#stap-1-het-bestand-indexhtml","title":"Stap 1: het bestand <code>index.html</code>","text":"<p>De eerste pagina die we gaan maken is het bestand <code>index.html</code>. Maak dit bestand aan in je <code>templates</code> directory en zet hier valide html in die de bezoeker vriendelijk verwelkomt. Voor nu is het prima om even de naam, die we na de vorige iteratie konden weergeven, te negeren \u2013 die voegen we later wel weer toe.</p> <p>Info</p> <p>De meeste webservers \u2013 en de ontwikkelserver van php die we steeds gebruiken \u2013 zijn zo geconfigueerd dat als een bezoeker geen specifiek bestand opvraagt via de <code>GET</code>-methode (dus een request naar bijvoorbeeld <code>localhost:8080/directory/</code>) de server op zoek gaan naar een bestand <code>index.html</code> of <code>index.php</code>. Hoewel we dit later met de hand gaan uitwerken, is dit dus wel het gedrag dat verwacht wordt.</p>"},{"location":"week4%20-%20mvc/iteratie3.html#stap-2-aanpassen-van-de-kernel","title":"Stap 2: aanpassen van de Kernel","text":"<p>Nu we dit bestand hebben gemaakt, is het van belang dat we in de <code>handle</code>-methode van onze <code>Kernel</code> de inhoud hiervan terugsturen in plaats van een hard-gecodeerde string. Maakt gebruik van de php-methode <code>file_get_contents()</code> om de inhoud van het zojuist gemaakte html-bestand als \u00e9\u00e9n langs string in te lezen, en maak een <code>Response</code> aan met deze string als body.</p> <p>Tip</p> <p>Hoewel je nu met het bestand <code>Kernel</code> aan het werk bent, moet je voor de juiste paden denken vanuit het bestand <code>public/index.php</code>: dit is immers het bestand dat door de server wordt uitgevoerd. In een latere stap gaan we dit nog wel aanpassen en configureerbaar maken.</p>"},{"location":"week4%20-%20mvc/iteratie3.html#stap-3-output-buffering","title":"Stap 3: Output buffering","text":"<p>Zoals tijdens de demonstratie is toegelicht, hebben bestanden die je in aan een methode hebt toegevoegd dezelfde scope als deze methode zelf. Dat houdt in dat je in die bestanden gebruik kunt maken van variabelen die je eerder in die methode hebt gedefinieerd. </p> <p>Maak gebruik van dit gegeven om de naam van de persoon (feitelijk de value van de query-parameter met de key <code>name</code>) weer via de template weer te geven. Je kunt dit eenvoudig doen door de in template gebruik te maken van <code>&lt;?= ... ?&gt;</code>-constructie die je tijdens het plenaire deel hebt gezien: zo kun je de template eigenlijk zien als een string met een php-script.</p> <p>Om deze string als script vervolgens uit te voeren, kun je gebruik maken van de php-functie <code>eval</code>. Dit print evenwel direct de inhoud naar de client (de browser), maar willen controle houden over wat er exact gebeurt. Gelukkig heeft php een techniek om de output te bufferen en op een later moment op te halen, aan te passen of alsnog te printen: hiervoor zijn met name de functies <code>ob_start()</code>, <code>ob_get_clean()</code> van belang. Bekijk eventueel de uitgebreide documentatie op php.net. </p> <p>Nog \u00e9\u00e9n kleine stap: om te voorkomen dat <code>eval</code> de html als php probeert uit te voeren, moeten we het geheel voorzien van een 'einde-php-tag': <code>?&gt;</code>. Zie het voorbeeld hieronder:</p> <pre><code>$naam = 'Henk';\nob_start();\n$f = '?&gt;' . file_get_contents('index.html');\neval($f);\n$res = ob_get_clean();\necho $res;\n</code></pre> <p>Warning</p> <p>De methode <code>eval</code> is natuurlijk erg gevaarlijk, omdat dit gewoon de code als php uitvoert. De infrastructuur die we nu hebben opgezet maakt het bijvoorbeeld erg gemakkelijk om allerlei gevaarlijke scripts in ons framework te injecteren. Dat gaan we op een later tijdstip nog wel veranderen.</p> <p></p>"},{"location":"week4%20-%20mvc/iteratie3.html#stap-4-een-beter-pad","title":"Stap 4: Een beter pad","text":"<p>Op dit moment is het request dat we moeten doen om onze vriendelijke welkomstboodschap op het scherm te krijgen wat ingewikkeld, met die vraagtekens en is-gelijktekens. We willen eigenlijk een logischer en moderner pad intypen om hetzelfde resultaat te krijgen. Wat we eigenlijk willen is dat een request naar <code>http://localhost:8080/welkom/Henk</code> de welkomstpagina voor Henk laat zien.</p> <p>Om dit voor elkaar te krijgen, moeten we allereerst de klasse <code>Request</code> aanpassen. Deze klasse heeft een (nu nog lege) methode <code>getUri():UriInterface</code>. </p> <p>```php</p>"}]}
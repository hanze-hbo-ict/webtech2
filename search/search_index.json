{"config":{"lang":["nl"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Webtechnologie 2","text":"<p>Dit vak gaat verder op de basis die in het vak Webtechnologie in de propedeuse is gelegd. In dit thema richten we ons op de backend van webapplicaties, waarbij de we server gebruiken om web-inhoud te genereren. Vanuit een korte historische inleiding lichten we toe waarom het web werkt zoals het werkt, gaan we in op de verschillende protocollen die hieraan ten grondslag liggen, en bespreken we ontwerpbeslissingen die het web maken wat het is. We gaan uitgebreid in op methoden en technieken die in hedendaagse webapplicaties gebruikt worden, waarbij we met name letten op de testbaarheid, onderhoudbaarheid en overdraagbaarheid van de applicatie.</p> <p>Het vak wordt afgesloten met een eindopdracht, waar studenten gedurende de periode aan werken. De eindopdracht wordt aan de hand van een beoordelingsformulier met een cijfer beoordeeld. Studenten mogen de opdracht in duo's doen, mits hierbij gebruik gemaakt wordt van pair programming. </p> <p>Deze pagina's zijn bedoeld om studenten op weg te helpen met de eindopdracht.</p>"},{"location":"week3%20-%20http/iteratie1.html","title":"iteratie 1: een volledige round-trip","text":""},{"location":"week3%20-%20http/iteratie1.html#beschrijving-van-de-inhoud","title":"Beschrijving van de inhoud","text":"<p>Tijdens het werkcollege pas je de ingebouwde functionaliteiten die PHP heeft om web requests te verwerken toe, met name de zogeheten superglobals. Daarnaast ga je aan de slag met het framework Symfony; dit framework zal gedurende het vak gebruikt worden als concreet voorbeeld van de behandelde patterns. In dit werkcollege pas je de component HttpFoundation toe, die de request- en responsestructuur van Symfony omvat.</p> <p>Je begint met de ontwikkeling van de eigen webapplicatie voor de eindopdracht door een eigen request handling component te ontwikkelen aan de hand van de patterns die in de colleges aan bod gekomen zijn. </p>"},{"location":"week3%20-%20http/iteratie1.html#stap-1-installeer-de-afhankelijkheden","title":"stap 1: installeer de afhankelijkheden","text":"<p>Nadat je de repository hebt gecloned, moet je de afhankelijkheden (dependencies) nog downloaden. De dependency-manager van php is composer. Zie ook de betreffende kennisclip hierover. </p> <p>Composer maakt gebruik van het bestand <code>package.json</code> om te checken welke afhankelijkheden er allemaal in het project zitten. Als je op dit bestand klikt, verschijnt er een dialoogvenster waarmee je direct composer kunt downloaden. Als dit gedaan is, kun je vervolgens de dependencies installeren: die komen in de directory <code>vendor</code> terecht.</p> <p> </p>"},{"location":"week3%20-%20http/iteratie1.html#stap-2-bestudeer-en-implementeer-de-message-gerelateerde-interfaces","title":"stap 2: bestudeer en implementeer de <code>Message</code>-gerelateerde interfaces.","text":"<p>Bestudeer de interfaces die gedefinieerd zijn in <code>vendor/Psr/http-message/src</code>. Deze week gaat het met name om de interfaces waarvan hieronder het diagram is weergegeven. </p> <p></p> <p>Wat is het fundamentele werk dat een web-framework moet doen? Het omzetten van een <code>ServerRequest</code> in een <code>Response</code>. Niet toevalligerwijs zie je deze twee klassen in het schema onderaan weergegeven. De klasse <code>ServerRequest</code> implementeert de interface <code>ServerRequestInterface</code> en de klasse <code>Response</code> implementeert de interface <code>ResponseInterface</code>. </p> <p>Zoals je ziet overeft <code>ServerRequest</code> van <code>Request</code> en overerft zowel <code>Request</code> als <code>Response</code> van <code>Message</code>. Allereerst zul je dus deze hele hi\u00ebrarchie van interfaces in implementerende klassen moeten weerspiegelen: doe dit in de directory <code>Http</code>. Als je in een klasse de betreffende interface implementeert, kun je met phpstorm automatisch stubs voor de betreffende methoden genereren.</p> <p>Tip</p> <p>Het is handigste wanneer je met het implementeren van de interfaces begint met de bovenste klassen, <code>Message</code> dus in dit geval. Op die manier voorkom je dat phpstorm stubs genereert van de hele hi\u00ebrarchie van interfaces.</p> <p></p> <p><code>ServerRequest</code> en <code>Request</code></p> <p>Meestal spreken we over het omzetten van een <code>Request</code> in een <code>Response</code>; waar komt dan ineens die <code>ServerRequest</code> vandaan?</p> <p>Als je de docs leest, staat er bij <code>Request</code> dat dit een representatie is van een outgoing, client side request, terwijl er bij <code>ServerRequest</code> staat dat dit een representatie is van een incoming, server side HTTP request. Het punt is dat webframeworks dikwijls zelf ook een request moeten maken, bijvoorbeeld naar een andere service of API. Hier is de <code>Request</code> voor nodig. Het <code>ServerRequest</code> is datgene dat het framework ontvangt, terwijl het <code>Request</code> datgene is dat de server (intern) verstuurt.</p>"},{"location":"week3%20-%20http/iteratie1.html#stap-3-de-kernel","title":"Stap 3: De Kernel","text":"<p>Nu hebben we al bijna de hele infrastructuur die nodig is om een eerste round trip te kunnen uitvoeren. Het enige dat we nog nodig hebben is de Kernel.</p> <p>In een web-framework is de Kernel de kern van de applicatie \ud83d\ude0e. Het is de centrale klasse die verantwoordelijk is voor het opstarten, configureren, en afhandelen van verzoeken. We gaan dit ding in de komende weken nog uitgebreid tegenkomen, maar voor nu hoeft -ie niet zo gek veel te doen.</p> <p>Maak een klasse <code>Kernel</code> die de <code>KernelInterface</code> implementeert (die staat in <code>vendor/hanze/itvb21web2-interfaces/src/Kernel</code>). Zoals je ziet overerft dit ding van <code>RequestHandlerInterface</code> die maar \u00e9\u00e9n methode heeft: <code>handle(ServerRequest):Response</code>. D\u00edt is dus de methode die uiteindelijk een request omzet in een response.</p> <p>Maak in de <code>handle</code>-methode van <code>Kernel</code> een nieuwe <code>Response</code> aan met gewoon een hard gecodeerde tekst als inhoud. Retourneer dit nieuwe object.</p>"},{"location":"week3%20-%20http/iteratie1.html#stap-4-de-klasse-request-en-response","title":"Stap 4: de klasse <code>Request</code> en <code>Response</code>","text":"<p>De methode <code>handle</code> moet een <code>ResponseInterface</code> teruggeven. Gelukkig hebben we hierboven een klasse <code>Response</code> gemaakt dit deze interface implementeert. Dit ding is een subklasse van <code>Message</code>, die in de constructor onder andere een string mee kan krijgen. Maak in <code>Response</code> een constructor die een string ontvangt en geef deze string door aan de superklasse. </p> <p>De constructor van <code>Message</code> vereist nog twee andere parameters: <code>protocol_version</code> en <code>headers</code>. Voor nu is het prima als je gewoon <code>\"1.1\"</code> en een lege array in stopt.</p> <p>Tip</p> <p>Een constructor in een php-klasse heeft de signature <code>public function __construct(...)</code>. Om de constructor van de superklasse aan te roepen, gebruik je <code>parent::__construct(...)</code>.</p> <p>De klasse <code>Request</code> is ook een subklasse van <code>Message</code>. Voorzie <code>Request</code> van een constructor waarmee je standaardwaarden voor de vereiste parameters aan de superklasse meegeeft (<code>parent::construct(\"1/1\", []., \"\")</code>) \u2013 we zullen dit in de refactorslag van deze week verbeteren.</p> <p>Implementeer tenslotte de methode <code>getBody()</code> in de klasse <code>Message</code>. Deze methode moet eenvoudig de <code>body</code> teruggeven die bij het aanmaken van een <code>Message</code> wordt meegegeven. Bestudeer de constructor van deze klasse om te zien hoe dit werkt.</p>"},{"location":"week3%20-%20http/iteratie1.html#de-frontcontroller","title":"De frontcontroller","text":"<p>In web-frameworks zoals deze is de frontcontroller het script dat het request in eerste instantie opvangt. In ons geval is dat het script <code>public/index.php</code>. Dit bestand bestaat nu nog uit maar \u00e9\u00e9n regel: <code>echo 'Hello world!;</code>. Het is de bedoeling dat we deze regel vervangen door het opzetten van de objecten-graaf op basis van de infrastructuur die we hierboven hebben gemaakt.</p> <pre><code>$app = new Kernel();\n$request = new ServerRequest();\n$response = $app-&gt;handle($request);\necho $response-&gt;getBody();\n</code></pre> <p>Nu kun je een server opstarten om de boel te testen. Ga naar de root van je project en start een php-ontwikkelserver op:</p> <pre><code>php -S localhost:8000 -t public\n</code></pre> <p>Als je nu met een browser naar <code>localhost:8000</code> gaat, zul je (als het goed is) de tekst te zien krijgen die je in de <code>handle</code>-methode van de Kernel hebt gebruikt om een <code>Response</code>-object aan te maken.</p> <p></p>"},{"location":"week3%20-%20http/iteratie2.html","title":"Iteratie 2: Uitbreiden van <code>ServerRequest</code> en <code>Response</code>","text":"<p>In de eerste iteratie hebben we gewoon een hard-gecodeerde string teruggegeven en maakten we helemaal geen gebruik van de mogelijkheden die het http ons biedt. In deze tweede iteratie gaan we dat aanpassen.</p>"},{"location":"week3%20-%20http/iteratie2.html#stap-1-superglobals-en-de-serverrequest-klasse","title":"Stap 1: superglobals en de <code>ServerRequest</code>-klasse","text":"<p>Bekijk de kennisclip over superglobals. Zoals hierin uitgelegd worden alle http-gerelateerde gegevens (en nog wel wat meer) opgeslagen in zogenaamde superglobals: globale variabelen die altijd overal beschikbaar zijn \u2013 zelfs zonder ze aan het begin van een methode te declareren.</p> <p>Op zich is dat heel fijn en makkelijk, maar het maakt onze code wel wat lastiger te testen en wat moeilijker te onderhouden. In principe willen we als software developers nooit gebruik maken van globals, laat staan superglobals. Verder willen we in onze php-applicatie eigenlijk alleen gebruik maken van php-variabelen, niet van relatief vreemde gegevens die schijnbaar zomaar uit de lucht komen vallen en eigenlijk meer in de http- dan bij de php-wereld thuishoren.</p> <p>Om dit te bewerkstelligen, moeten we ergens een vertaling maken van de http- naar de php-wereld. De meest aangewezen plek hiervoor is de klasse die verantwoordelijk is voor het opvangen van het inkomende request: de klasse <code>ServerRequest</code>.</p> <p>Deze klasse heeft op dit moment nog geen constructor, maar als je goed naar de methoden uit de interface kijkt, zie je dat dit ding de meeste http-gegevens encapsuleert. We moeten er dus voor zorgen dat instanties van <code>ServerRequest</code> beschikking krijgen over deze gegevens. Zoals je in de kennisclip hebt kunnen zien, zijn die min of meer functioneel onderverdeeld. Je hebt <code>$_GET</code>, <code>$_POST</code>, <code>$_SERVER</code> enzovoort. Klik hier voor het volledige overzicht.</p> <p>De algemene flow van onze frontcontroller wordt dan als volgt:</p> <p></p> <p>We moeten dus een instantie maken van de <code>ServerRequest</code>-klasse waardoor deze de superglobals kan encapsuleren. Maak in deze klasse een statische methode <code>fromGlobals()</code> die een <code>ServerRequest</code>-object teruggeeft. Zie het onderstaande code-fragment:</p> <pre><code>class ServerRequest {\n    public function __construct(private array $get) {}\n    public static function fromGlobals():ServerRequestInterface {\n        return new self($_GET);\n    }\n}\n</code></pre> <p>Warning</p> <p>Die methode <code>fromGlobals()</code> is de enige plek in ons framework waar we gebruik maken van die superglobals. Overal anders wordt vanaf nu gebruik gemaakt van deze instantie van die <code>ServerRequest</code>, die door deze methode teruggegeven wordt.</p> <p>Zoals aangegeven wordt in php de waarden na het vraagteken in de URL query parameters genoemd. Als we bijvoorbeeld een request doen naar <code>whatever.com/dingen?sleutel1=waarde1&amp;sleutel2=waarde2</code>, dan wordt de corresponderende <code>$_GET</code>:</p> <pre><code>Array\n(\n    [sleutel1] =&gt; waarde1\n    [sleutel2] =&gt; waarde2\n)\n</code></pre> <p>Maak van dit gegeven gebruik om de methode <code>getQueryParams</code> in <code>ServerRequest</code> te implementeren.</p>"},{"location":"week3%20-%20http/iteratie2.html#stap-2-de-handle-methode-in-de-kernel","title":"Stap 2: de <code>handle</code>-methode in de Kernel","text":"<p>Omdat de <code>handle</code>-methode in de Kernel die instantie van de <code>ServerRequest</code> mee krijgt, kunnen we hier gebruik maken van de methode <code>getQueryParams</code> die je hierboven hebt ge\u00efmplementeerd. Maak van deze mogelijkheid gebruik om de waarde van de sleutel <code>naam</code> op te halen, zodat iemand een request kan doen naar <code>localhost:8000:?naam=henk</code>.</p> <p>Gebruik de waarde die de bezoeker heeft ingetypt op je vriendelijke welkomstboodschap wat persoonlijker te maken. Hou er wel rekening mee dat de sleutel <code>naam</code> niet per se hoeft te bestaan: je moet dus een standaardwaarde hiervoor aangeven.</p> <p></p>"},{"location":"week3%20-%20http/refactor.html","title":"Refactoring","text":"<p>Nu we een eenvoudige round-trip hebben kunnen maken, is het tijd om de code wat te verbeteren. Omdat we in deze eerste iteratie eigenlijk maar maar met drie klassen hebben gewerkt, hoeven we alleen deze maar te bekijken.</p>"},{"location":"week3%20-%20http/refactor.html#de-klassen-serverrequest-request-en-message","title":"De klassen <code>ServerRequest</code>, <code>Request</code> en <code>Message</code>","text":"<p>De belangrijkste omissie die we in deze iteratie hebben laten liggen is dat we de exacte constructors van de superklassen van <code>ServerRequest</code> nog hebben genegeerd. Bestudeer de methoden uit de interface van de verschillende klassen om te kijken welke informatie in welke klasse moet worden opgeslagen. Zo heeft bijvoorbeeld de klasse <code>Request</code> een methode <code>getMethod()</code>, die de betreffende htt-method (<code>POST</code>, <code>GET</code>, <code>UPDATE</code>, <code>DELETE</code>, ...) als string teruggeeft.</p> <p>Omdat we (nog) geen instantie van <code>Request</code> direct aanmaken, moeten we deze informatie tijdens het aanmaken van de subklasse, <code>ServerRequest</code> meegeven. Gelukkig hebben we in deze subklasse de beschikking over deze informatie: die kun je vinden in <code>$_SERVER['REQUEST_METHOD']</code>, die juist door deze klasse wordt ge\u00ebncapsuleerd. </p> <p>Een ander voorbeeld: de klasse <code>Message</code> heeft een methode <code>getHeaders()</code> die alle http-headers als array teruggeeft. Ook deze gegevens moeten via <code>ServerRequest</code> en <code>Request</code> aan de <code>Message</code> doorgegeven worden. Let op: alle http-headers zitten in de superglobal <code>$_SERVER</code>: dat zijn namelijk die gegevens uit deze array waarvan de naam (de key) met <code>HTTP_</code> begint. Je zult deze gegevens dus uit deze array moeten filteren en de liggende streepjes vervangen door koppeltekens.</p> <p>Tip</p> <p>Je kunt natuurlijk gewoon door de <code>$_SERVER</code> heen itereren, checken of de sleutel (key) begint met <code>HTTP_</code> en in dat geval de corresponderende waarde gebruiken. Maar je kunt ook gebruik maken van de methoden <code>array_filter()</code> en <code>array_map</code>.</p> <p>Het is een klein beetje arbitrair waar je deze wijzigingen exact uitvoert, maar het is het netste als je dit doet in <code>ServerRequest</code>, zodat zowel <code>Request</code> als <code>Message</code> gewoon een nette array ontvangen.</p> <p>Warning</p> <p>We hebben het hierboven wel steeds over de superglobal, maar het is natuurlijk niet de bedoeling dat je deze gebruikt. Je moet telkens de ge\u00ebncapsuleerde versie uit <code>ServerRequest</code> gebruiken.</p> <p>Doe dit voor alle velden uit de verschillende klassen waarvan je ziet dat ze die gegevens nodig hebben. Als het goed is zul je zien dat de constructor van <code>ServerRequest</code> vijf superglobals nodig heeft. Let op dat de parameter <code>$body</code> in <code>Message</code> ook leeg kan zijn: een <code>GET</code>-request heeft in de regel geen body, net zo min als een <code>POST</code>-response.</p> <p>Tip</p> <p>De klasse <code>Request</code> heeft een property van het type <code>UriInterface</code> nodig. Het is prima om die voor nu even optioneel te maken, of om hier ook een string in te kunnen zetten (gebruik hiervoor <code>UriInterface|string</code>): in [de volgende iteratie] gaan we hier uitgebreid op in.</p>"},{"location":"week3%20-%20http/refactor.html#de-klasse-response","title":"De klasse <code>Response</code>","text":"<p>Ga door de methoden van <code>Response</code> om te onderzoeken welke velden deze klasse allemaal nodig heeft (feitelijk op dezelfde manier als hierboven). Let er ook op dat deze klasse ook overerft van <code>Message</code>, dus ook hier moeten we de constructor aanpassen zodat die <code>Message</code> op een goede manier wordt aangemaakt. </p> <p>Zorg voor logische standaardwaarden van alle velden (<code>status-code</code> = 200, bijvoorbeeld, of <code>protocol-version</code> = \"1.1\"): dat maakt het aanmaken van instanties van deze klasse een stuk eenvoudiger.</p> <p>In de vorige iteratie hebben we gewoon <code>echo $response-&gt;getBody()</code> gebruikt om de response naar de client te sturen. Het is veel netter om hier een speciale statische functie voor te maken, die een <code>Response</code>-object ontvangt, de body hiervan uitprint en niet teruggeeft: dan hebben we fijn \u00e9\u00e9n specifieke plek waar we de boel naar de client terugsturen en weten we waar we op een later tijdstip moeten zijn om (bijvoorbeeld) de headers mee te sturen.</p> <p>Maak in <code>Response</code> een methode <code>static send(Response $response)</code> die precies dit doet. Voor nu is het nog voldoende om gewoon die body uit te printen \u2013 op een later tijdstip gaan we dit nog wel (significant) aanpassen.</p>"},{"location":"week3%20-%20http/refactor.html#laatste-stappen","title":"Laatste stappen","text":"<p>Implementeer de methoden die nu nog commentaar hebben dat ze ge\u00efmplementeerd moeten worden.</p> <p>Pas de frontcontroller aan, zodat deze gebruik maakt van de statische methode <code>Response::send()</code>.</p> <p>Check opnieuw de werking van het geheel. Bij een refactorslag is het niet de bedoeling dat je nieuwe functionaliteit toevoegt, dus als het goed is, is er niks veranderd.</p>"},{"location":"week4%20-%20mvc/iteratie3.html","title":"Iteratie 3: Model View Controller","text":""},{"location":"week4%20-%20mvc/iteratie3.html#beschrijving-van-de-inhoud","title":"Beschrijving van de inhoud","text":"<p>Je implementeert een model-view-controllerarchitectuur in de eigen webapplicatie voor de eindopdracht door eigen routing en templating componenten te ontwikkelen aan de hand van de patterns die in de colleges besproken zijn.</p> <p>Nu we in staat zijn om vanuit onze frontcontroller een stuk tekst in de browser te laten zien, is het zaak om deze tekst in een separaat bestand onder te brengen. Het zou immers niet handig zij om in onze Kernel alle mogelijke pagina's op te nemen die ons framework kan laten zien: dat zou de klasse erg vervuilen met html, wat de boel onoverzichtelijk en ononderhoudbaar zou maken. </p> <p>De html-bestanden die we gaan maken, vormen min of meer de View in het model-view-controller ontwerppatroon. Feitelijk zijn dit niet per se html-bestanden, maar meer staketsels van html, die we later via de controller gaan vullen met data uit het model. Hierom spreken we niet van html-bestanden, maar van html-templates, of kortweg templates.</p> <p></p> <p>Het is een beetje een discusie waar op je file system je deze templates neerzet, maar in deze uitwerking gaan we uit van een directory <code>tempates</code> die naast de directories <code>public</code> en <code>src</code> staat:</p> <pre><code>app/\n\u251c\u2500 composer.json\n\u251c\u2500 public/\n\u251c\u2500 src/\n\u251c\u2500 templates/\n\u251c\u2500 vendor/\n</code></pre>"},{"location":"week4%20-%20mvc/iteratie3.html#stap-1-het-bestand-indexhtml","title":"Stap 1: het bestand <code>index.html</code>","text":"<p>De eerste pagina die we gaan maken is het bestand <code>index.html</code>. Maak dit bestand aan in je <code>templates</code> directory en zet hier valide html in die de bezoeker vriendelijk verwelkomt. Voor nu is het prima om even de naam, die we na de vorige iteratie konden weergeven, te negeren \u2013 die voegen we later wel weer toe.</p> <p>Info</p> <p>De meeste webservers \u2013 en de ontwikkelserver van php die we steeds gebruiken \u2013 zijn zo geconfigueerd dat als een bezoeker geen specifiek bestand opvraagt via de <code>GET</code>-methode (dus een request naar bijvoorbeeld <code>localhost:8080/directory/</code>) de server op zoek gaan naar een bestand <code>index.html</code> of <code>index.php</code>. Hoewel we dit later met de hand gaan uitwerken, is dit dus wel het gedrag dat verwacht wordt.</p>"},{"location":"week4%20-%20mvc/iteratie3.html#stap-2-aanpassen-van-de-kernel","title":"Stap 2: aanpassen van de Kernel","text":"<p>Nu we dit bestand hebben gemaakt, is het van belang dat we in de <code>handle</code>-methode van onze <code>Kernel</code> de inhoud hiervan terugsturen in plaats van een hard-gecodeerde string. Maakt gebruik van de php-methode <code>file_get_contents()</code> om de inhoud van het zojuist gemaakte html-bestand als \u00e9\u00e9n langs string in te lezen, en maak een <code>Response</code> aan met deze string als body.</p> <p>Tip</p> <p>Om dit goed te laten werken moet je natuurlijk weten waar de <code>Kernel</code> zich bevindt in de scope van de hele applicatie. Omdat je de applicatie runt vanaf je frontcontroller (<code>/public/public</code>) kan het zijn dat je bestanden wilt opzoeken vanaf die directory, terwijl als je denkt vanuit de <code>Kernel</code> je een heel ander pad moet gebruiken naar de template.</p> <p>Je kunt gebruik maken van de constante <code>__DIR__</code> om te weten te komen waar het bestand staat waar die <code>__DIR__</code> in genoemd is. Als je die weglaat, gaat php standaard uit van het bestand dat je runt (<code>public/index.php</code> in dit geval dus).</p>"},{"location":"week4%20-%20mvc/iteratie3.html#stap-3-output-buffering","title":"Stap 3: output buffering","text":"<p>Zoals tijdens de demonstratie is toegelicht, hebben bestanden die je in aan een methode hebt toegevoegd dezelfde scope als deze methode zelf. Dat houdt in dat je in die bestanden gebruik kunt maken van variabelen die je eerder in die methode hebt gedefinieerd. </p> <p>Maak gebruik van dit gegeven om de naam van de persoon (feitelijk de value van de query-parameter met de key <code>name</code>) weer via de template weer te geven. Je kunt dit eenvoudig doen door de in template gebruik te maken van <code>&lt;?= ... ?&gt;</code>-constructie die je tijdens het plenaire deel hebt gezien: zo kun je de template eigenlijk zien als een string met een php-script.</p> <p>Om deze string als script vervolgens uit te voeren, kun je gebruik maken van de php-functie <code>eval</code>. Dit print evenwel direct de inhoud naar de client (de browser), maar willen controle houden over wat er exact gebeurt. Gelukkig heeft php een techniek om de output te bufferen en op een later moment op te halen, aan te passen of alsnog te printen: hiervoor zijn met name de functies <code>ob_start()</code>, <code>ob_get_clean()</code> van belang. Bekijk eventueel de uitgebreide documentatie op php.net. </p> <p>Nog \u00e9\u00e9n kleine stap: om te voorkomen dat <code>eval</code> de html als php probeert uit te voeren, moeten we het geheel voorzien van een 'einde-php-tag': <code>?&gt;</code>. Zie het voorbeeld hieronder:</p> <pre><code>$naam = 'Henk';\nob_start();\n$f = '?&gt;' . file_get_contents('index.html');\neval($f);\n$res = ob_get_clean();\necho $res;\n</code></pre> <p>Warning</p> <p>De methode <code>eval</code> is natuurlijk erg gevaarlijk, omdat dit gewoon de code als php uitvoert. De infrastructuur die we nu hebben opgezet maakt het bijvoorbeeld erg gemakkelijk om allerlei gevaarlijke scripts in ons framework te injecteren. Dat gaan we op een later tijdstip nog wel veranderen.</p> <p></p>"},{"location":"week4%20-%20mvc/iteratie4.html","title":"Iteratie 4: meer paden","text":""},{"location":"week4%20-%20mvc/iteratie4.html#stap-1-de-klasse-uri","title":"Stap 1: De klasse Uri","text":"<p>Bij de laatste refactoring hebben we de klasse <code>Uri</code> nog genegeerd - we zeiden dat we daar vooralsnog een string in mochten stoppen. Nu is het tijd om dit stuk code op te ruimen.</p> <p>Maak, opnieuw in de directory <code>Http</code>, een klasse <code>Uri</code> die (vanzelfsprekend) de interface <code>UriInterface</code> implementeert. Laat phpstorm de null-implementaties van de gewenste methode cre\u00ebren.</p> <p>Zoals je kunt lezen is dit een uitwerking van RFC 3986. Bestudeer de presentatie van het theoriecollege om te weten welke onderdelen van een url corresponderen met welke term uit deze RFC.</p> <p>URI, URL en URN</p> <p>Er zijn feitelijk drie verschillende termen die horen bij een internetadres: URL, URN en URI. Een URI (Uniform Resource Identifier) is een string van karakters waarmee een naam, een adres of een resource op het internet ge\u00efdentificeerd kan worden. </p> <p>Een URI (Uniform Resource Identifier) is een overkoepelende term voor een string die een specifieke resource identificeert, hetzij door lokalisatie, naamgeving, of beide. Binnen deze categorie vallen URL's (Uniform Resource Locators), die niet alleen identificeren maar ook de locatie en het toegangsmechanisme (zoals <code>http://</code> of <code>ftp://</code>) specificeren. Een URN (Uniform Resource Name), tenslotte, is een URI die uitsluitend bedoeld is als permanente naam zonder dat deze een specifieke locatie of toegangsmethode hoeft te bevatten, zoals een ISBN voor boeken. Kortom, elke URL en URN is een URI, maar een URI hoeft niet per se een URL of een URN te zijn.</p> <p>Bestudeer eventueel ook de documentatie op w3.org.</p> <p></p> <p>Bestudeer de interface om te kijken wat er zoal van de klasse gevraagd wordt. Zoals je ziet heeft deze interface een hele zooi methoden. We gaan die in eerste instantie niet allemaal uitwerken: vooralsnog gebruiken we alleen de methoden die we nodig hebben om relatief eenvoudige requests zoals die hierboven is weergegeven te representeren. Zorg ervoor dat deze gegevens via de constructor van <code>Uri</code> worden opgeslagen. Implementeer ook de corresponderende <code>get</code>- en <code>with</code>-methoden.</p> <p>Tip</p> <p>We slaan de gegevens voor nu in <code>Uri</code> nog even op als string. Op een later tijdstip zullen we dit nog moeten aanpassen, omdat niet alle karakters zonder meer in een webadres kunnen voorkomen, \u00e9n omdat we mogelijk nog een eigen protocol gaan ontwerpen.</p> <p>Maak vervolgens in <code>ServerRequest</code> een instantie aan van <code>Uri</code>, waarin de gevraagde gegevens via de waarden uit de betreffende encapsulaties van de superglobals worden opgeslagen \u2013 let op dat je juiste standaard-waarden aan de betreffende velden meegeeft wanneer deze niet bestaan. Pas het type van de parameter uit <code>Request</code> aan dat deze geen strings meer kan bevatten en geef het zojuist gecre\u00eberde <code>Uri</code>-object vanuit <code>ServerRequest</code> mee.</p> <p>Feitelijk zijn we hier bezig met een refactorslag, die we wel echt nodig hebben om de volgende stap uit te kunnen worden. Na afloop van deze stap is dus als het goed is geen extra functionaliteit ge\u00efntroduceerd.</p> <p>Info</p> <p>Wanneer we in deze uitleg spreken over de superglobals, bedoelen we natuurlijk de weergave of opslag daarvan in het <code>ServerRequest</code>-object.</p>"},{"location":"week4%20-%20mvc/iteratie4.html#stap-2-een-beter-pad","title":"Stap 2: een beter pad","text":"<p>De manier waarop we nu onze vriendelijke welkomstpagina te zien krijgen is wat onduidelijk. Je moet maar net weten dat je een request moet doen naar <code>index.php?naam=&lt;naam&gt;</code>; sowieso is het wat ongebruikelijk om met dit soort request-parameters te werken. Laten we dit pad vervangen door een request naar <code>welkom/&lt;naam&gt;</code> \u2013 dat kunnen we nu doen, doordat we alle noodzakelijke gegevens in het <code>Uri</code>-object hebben opgeslagen.</p> <p>Vooralsnog wordt het noodzakelijke werk gedaan in de methode <code>handle</code> van de <code>Kernel</code>. Deze methode krijgt de <code>request</code> mee, waarin de <code>uri</code> zit, waarin het veld <code>path</code> is opgeslagen. Wanneer we dit gegeven even uitprinten, krijgen we het volgende resultaat:</p> <pre><code># in de klasse `Kernel`:    \npublic function handle(ServerRequestInterface $request): ResponseInterface\n    {\n        print_r($request-&gt;getUri()-&gt;getPath());\n    }\n}\n</code></pre> <p></p> <p>Maak gebruik van dit gegeven om te checken of de request gedaan is naar <code>welkom/&lt;naam&gt;</code>. Je zult hiervoor dus het pad moeten splitsen op <code>/</code>, waarbij het eerste deel gelijk moet zijn aan <code>welkom</code> en het tweede deel de naam bevat (die is dus variabel). Pas hiervoor de code in <code>handle</code> in <code>Kernel</code> aan.</p>"},{"location":"week4%20-%20mvc/iteratie4.html#stap-3-een-tweede-pad","title":"Stap 3: een tweede pad","text":"<p>Nu we deze techniek hebben, kunnen we natuurlijk relatief eenvoudig een tweede pad toevoegen. Hiervoor hoeven we in principe alleen maar het betreffende pad in de <code>handle</code>-methode van de <code>Kernel</code> op te nemen en de juiste output te genereren.</p> <p>Maak een tweede html-pagina aan in de <code>templates</code>-directory; wat erin staat is voor nu niet zo gek belangrijk \u2013 wij gebruiken in dit voorbeeld een pagina die het weer weergeeft. Bedenk een voor de hand liggend pad dat iemand moet intypen om deze pagina te zien te krijgen (in ons voorbeeld is dit een request naar <code>/weer</code>). Voeg in de <code>handle</code>-methode in de <code>Kernel</code> een check toe die kijkt of het invulde pad hiermee correspondeert en geef de betreffende pagina terug.</p> <p></p> <p>Success</p> <p>We hebben nu de infrastructuur opgezet om eenvoudig verschillende requests door verschillende onderdelen van ons script af te handelen. Voorlopig is het alleen maar het laten zien van verschillende pagina's, maar je kunt deze structuur natuurlijk gebruiken om heel verschillende wegen door de applicatie aan te spreken.</p>"},{"location":"week4%20-%20mvc/iteratie5.html","title":"Iteratie 5: Controllers en Routers","text":"<p>Hoewel de functionaliteit nu op zich prima werkt, kun je je wel voorstellen dat dit niet schaalt. Hoe meer verschillende paden we in onze applicatie willen opvangen, hoe ingewikkelder onze <code>handle</code>-methode in de <code>Kernel</code> wordt. Dit is een gevolg van het feit dat we alle functionaliteit feitelijk in precies deze methode hebben gestopt. In het kader van seperation of concerns is het veel beter om de verschillende stappen door verschillende klassen uit te laten voeren. Dat is waar de Controllers in beeld komen.</p> <p>Bekijk nog eens de betreffende dia uit het theoriecollege (zie hieronder). Het gaat hier met name om de onderste helft van dit plaatje. De bezoeker heeft een informatiebehoefte en typt hiervoor een url in de navigatiebalk van de webbrowsers, waardoor een request wordt ge\u00efnitieerd. Zoals je ziet wordt dit request opgevangen door een controller, die vervolgens de view update die weer naar de client wordt teruggestuurd. Voor nu negeren we even het model.</p> <p></p>"},{"location":"week4%20-%20mvc/iteratie5.html#stap-1-de-controllers","title":"Stap 1: de controllers","text":"<p>Controllers zijn feitelijk klassen die - via de Kernel \u2013 de requests afhandelen. Hierom moeten alle controllers instanties zijn van de <code>RequestHandlerInterface</code>, die je in <code>vendor/psr/http-server-handler/src/RequestHandlerInterface.php</code> kunt vinden. </p> <p>Bestudeer deze interface. Zoals je ziet heeft deze maar \u00e9\u00e9n methode <code>handle(ServerRequestInterface):ResponseInterface</code>. Dit lijkt natuurlijk als twee druppels water op de <code>handle</code>-methode in onze <code>Kernel</code>-klasse, maar controllers zitten n\u00e9t even ergens anders in de round-trip:</p> <ol> <li><code>Kernel</code> wordt aangemaakt.</li> <li><code>ServerRequestObject</code> wordt aangemaakt.</li> <li>De methode <code>handle</code> in <code>Kernel</code> wordt aangeroepen.</li> <li>In deze methode wordt de juiste <code>Controller</code> voor deze <code>Request</code> gebruikt.</li> <li>Deze <code>Controller</code> geeft de bijhorende <code>Response</code> aan de <code>Kernel</code> terug.</li> <li>De <code>Kernel</code> retourneert deze <code>Response</code>.</li> <li>Deze <code>Response</code> wordt naar de client gestuurd.</li> </ol> <p>Zo zie je dat de Kernel de verantwoordelijkheid van het maken van de juiste <code>Response</code> verlegt naar een <code>Controller</code>. Omdat alle controllers dezelfde interface implementeren, maakt het voor de Kernel niet uit wie de response heeft gemaakt: deze klasse is alleen maar ge\u00efnteresseerd in dat er een response komt die hij kan terugsturen naar de frontcontroller.</p> <p>Momenteel hebben we twee pagina's: <code>welkom</code> en <code>weer</code>. Maak een nieuwe directory <code>Controllers</code> met hierin voor beide pagina's een klasse die de <code>RequestHandlerInterface</code> implementeert. Noem de klassen <code>WelkomController</code> en <code>WeerController</code> (je verwacht het niet \ud83d\ude0e).</p> <p>Verplaats de functionaliteit die je tot nu toe in de <code>handle</code>-methode van de <code>Kernel</code> hebt staan naar de <code>handle</code>-methode van de betreffende controller \u2013 bedenk zelf een goede techniek om die variabele uit het pad (<code>&lt;naam&gt;</code>) in de <code>WelkomController</code> te krijgen. Gebruik de check die je in <code>Kernel</code> hebt staan om \u00e9\u00e9n van beide pagina's te laten zien om een instantie van de juiste controller aan te maken. Roep vervolgens de <code>handle</code>-methode op deze controller aan en retourneer de response die je van de controller terugkrijgt.</p>"},{"location":"week4%20-%20mvc/iteratie5.html#stap-2-de-router","title":"Stap 2: de router","text":"<p>Onze applicatie begint nu werkelijk te groeien. We kunnen verschillende paden opvragen en afhankelijk hiervan fijn verschillende pagina's laten zien. Het is alleen nog wel een beetje stom dat we onze kernel moeten openen om te zien welke controllers bij welk pad horen - en ook om eventuele nieuwe controllers en nieuwe paden toe te voegen. Dat is wat onhandig, het schaalt niet en past ook niet bij het Single Responsibility Principle. Het is tijd om de klasse <code>Router</code> toe te voegen.</p> <p>De klasse <code>Router</code> is verantwoordelijk voor het hijbouden welke controller bij welk pad (welke route) hoort. Bekijk nog een keer de betreffende dia uit het hoorcollege:</p> <p></p> <p>Bestudeer de interface <code>RoutingInterface</code>, die je kunt vinden in <code>vendor/hanze/itvb21web2-interfaces/src/Routing/RouterInterface.php</code>. Maak een klasse <code>Router</code> in de namespace <code>Framework\\Routing</code> die deze interace implementeert. De methode <code>route</code> geeft een <code>RequestHandlerInterface</code> terug, wat natuurlijk onze controllers zijn die we in de stap hierboven hebben gemaakt.</p> <p>Maak in je frontcontroller een associatieve array met de paden (routes) als key en de controllers als value. Let op: het volledige pad kan natuurlijk iets zijn als <code>welkom/&lt;naam&gt;</code> of <code>blogpost/&lt;id&gt;</code>. Begin met het matchen van de letterlijke string (dus bijvoorbeeld <code>welkom</code> en <code>weer</code>, in ons voorbeeld). Zorg ervoor dat de waarden van deze array de volledige klassenaam van de controller die bij dit pad hoort is. We zullen in de laatste iteratie van deze week dit nog wat uitbreiden.</p> <p>Maak vervolgens, eveneens in je frontcontroller, een instantie aan van <code>Route</code>, waarbij je deze assiociatieve array meegeeft. Geeft tenslotte deze intantie weer mee aan de <code>Kernel</code> die je al eerder hebt gemaakt (je zult dus de constructor van <code>Kernel</code> ook moeten aanpassen).</p> <p>Tip</p> <p>Om in php het volledige pad van een klasse te krijgen, kun je gebruik maken van de syntax <code>KlassseNaam::class</code>.</p> <p>Pas tenslotte de methode <code>handle</code> in <code>Kernel</code> aan, zodat deze gebruik maakt van de instantie van <code>Route</code> die je bij het aanmaken hiervan hebt meegegeven. Test je resultaat tot zover door een nieuwe route met bijhorende controller en view (html-pagina) te maken. Maak ook een <code>FileNotFoundController</code> met bijhorende pagina en zorg ervoor dat deze controller wordt gebruikt wanneer in de methode <code>route</code> in <code>Router</code> het opgevraagd pad niet bestaat (dat wil zeggen niet in de associatieve array voorkomt).</p> <p></p>"},{"location":"week4%20-%20mvc/iteratie6.html","title":"Iteratie 6: een betere matching","text":"<p>Als laatste stap in deze week moeten we er nog voor zorgen dat de routes beter worden gematcht. Vooralsnog gebruikten we een hard string als key in de klasse <code>Route</code>, maar da's natuurlijk niet handig. Er kan natuurlijk veel meer in zo'n route zitten terwijl het door dezelde controller moet worden afgehandeld. Bekijk de volgende voorbeelden:</p> methode route match variable-part controller <code>GET</code> <code>/welkom/piet</code> <code>/welkom</code> 'piet' <code>WelkomController</code> <code>GET</code> <code>/welkom/Chantal</code> <code>/welkom</code> 'Chantal' <code>WelkomController</code> <code>POST</code> <code>/welkom/henk</code> <code>/welkom</code> 'henk' <code>WelkomController</code> <p>Om al deze mogelijke paden op te kunnen vangen, is het nodig dat we een nieuwe klasse <code>Route</code> maken, die op basis van een aantal gegevens bepaalt of de opgevraagde URI past bij deze route. Bestudeer het onderstaande klassediagram:</p> <p></p>"},{"location":"week4%20-%20mvc/iteratie6.html#stap-1-de-klasse-route","title":"Stap 1: de klasse <code>Route</code>","text":"<p>Maak een klasse <code>Route</code> in dezelfde namespace als waar je je <code>Router</code> hebt gezet. Deze klasse zorgt feitelijk voor een koppeling tussen een pad en een bijhorende controller. Zorg ervoor dat bij het aanmaken van instanties van deze klasse deze beide gegevens moeten worden meegegeven. Je kunt natuurlijk ook verschillende routes hebben voor verschillende typen requests, afhankelijk van de http-methode. Zorg er ook voor dat dit in de klasse wordt opgenomen, waarbij je standaard uitgaat van <code>GET</code>.</p> <p>Voorzie deze klasse van een methode die een <code>ServerRequestInterface</code>-object ontvangt en op basis van de daarin ge\u00ebncapsuleerde uri en methode teruggeeft of deze <code>Route</code> bij de request past of niet (het return-type van deze methode is dus <code>bool</code>). Je zult doet iets slims met reguliere expressies moeten doen om de verschillende mogelijkheden van een route te ondervangen (zie de tabel hierboven).</p> <p>Omdat de instanties van <code>Route</code> weten welke controller bij welk pad moet worden aangeroepen, is die de klasse waar we deze koppeling expliciet kunnen leggen. Maak hiervoor in <code>Route</code> een methode die opnieuw een <code>ServerRequestInterface</code> ontvangt en de methode <code>handle</code> aanroept op de controller die bij deze specifieke <code>Route</code>-instantie is opgeslagen. Deze methode retourneert dus feitelijk de <code>Response</code> die door de aangeroepen controller wordt teruggegeven.</p>"},{"location":"week4%20-%20mvc/iteratie6.html#stap-2-aanpassingen-in-de-klasse-router","title":"Stap 2: aanpassingen in de klasse <code>Router</code>","text":"<p>In de vorige iteratie maakten we voor de routes gebruik van een associatieve array die paden koppelde aan controllers. Nu we een nieuwe separate klasse daarvoor hebben, moeten we daar natuurlijk van gebruik maken. Zorg ervoor dat de array in je frontcontroller alleen nog maar instanties van de klasse <code>Route</code> bevat.</p> <p>Nu we een separate klasse voor de routes zelf hebben, moeten we daar natuurlijk gebruik van maken in onze <code>Router</code>. Pas de methode <code>route</code> aan, zodat deze over de lijst van opgeslagen routes heen loopt en telkens checkt of het request past op de gegeven route (maak dus gebruik van de methode die je in de eerste stap van deze iteratie hebt gemaakt). Als de match gevonden is, retourneer dan die route.</p> <p>Pas de methode <code>handle</code> in de <code>Kernel</code> aan, zodat deze van de <code>Router</code> de juiste <code>Route</code> terugkrijgt. Roep vervolgens op deze <code>Route</code> de methode aan die je in <code>Route</code> hebt gemaakt om de bijhorende controller aan te maken en uit te voeren. Retourneer de response aan de frontcontroller. Zie onderstaand sequentiediagram om een beeld te krijgen van hoe deze klassen allemaal met elkaar samenwerken.</p>"},{"location":"week4%20-%20mvc/refactor.html","title":"Refactoring","text":""},{"location":"week4%20-%20mvc/refactor.html#stap-1-controllers-naar-app","title":"Stap 1: Controllers naar <code>App</code>","text":""},{"location":"week4%20-%20mvc/refactor.html#stap-2-begin-maken-met-tekstuele-configuratie","title":"Stap 2: Begin maken met tekstuele configuratie","text":""}]}